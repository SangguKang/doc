/* 거리 측정에 따른 LED On/Off */
void loop()
{
    //초음파 신호 송신
    pinMode(9, OUTPUT);
    digitalWrite(9, LOW);
    delayMicroseconds(2);
    digitalWrite(9, HIGH);
    delayMicroseconds(5);
    digital Write(9, LOW);

    //초음파 신호 수신
    pinMode(9, INPUT);
    double duration = pulseIn(9, HIGH);
    double m = duration / 1000000 * 340 / 2; //if duration is 1,000us, duration is 1000 / 1000000 seconds.

    if(m < 0.2)
    {
        digitalWrite(7, HIGH);
        digitalWrite(6, LOW);
        digitalWrite(5, LOW);
    }
    else if(m < 60)
    {
        digitalWrite(7, LOW);
        digitalWrite(6, HIGH);
        digitalWrite(5, LOW);
    }
    else
    {
        digitalWrite(7, LOW);
        digitalWrite(6, LOW);
        digitalWrite(5, HIGH);
    }
    
}

/*
거리(m) = 속력(m/s) * 시간(s)
주파수(Hz) = 1 / 시간(s)

테이블을 통해 주파수별 속력을 알 수 있다는 가정. 주파수를 구하면 시간을 구할 수 있고, 시간을 구하면 주파수별 속력을 알 수 있으므로 거리를 구할 수 있다.
거리가 몇 이하이면 무시(LED Off)하고 거리가 몇 이상이면 정상 동작.
주파수가 몇 이하이면(속력이 몇 이하이면) 무시.
interrupt routine에서는 flag만 설정. main loop에서 flag가 뜨면 interrupt pin을 input으로 인식해서 구간 시간(count 횟수)을 구할 수 있는가?
정해진 시간 동안 interrupt flag 카운팅으로 시간을 구할 수 있는가?
*/

/*
아두이노 PulseIn()함수
핀에서 펄스(HIGH 또는 LOW)를 읽습니다. 예를 들어, value 가 HIGH 이면, pulseIn() 은 핀이 HIGH` 가 될 때까지 기다리고, 타이머를 시작하고, 핀이 LOW 가 될 때까지 기다리고 타이머를 멈춥니다. 
펄스의 길이를 마이크로초 단위로 반환합니다. 정해진 timeout 안에 펄스가 시작되지 않으면 0을 반환합니다. 이 함수의 타이머는 경험적으로 결정되고, 긴 펄스에 대해 오류를 낼 수도 있습니다. 
10 마이크로초부터 3분까지의 길이의 펄스에 대해 동작합니다.
pulseIn(pin, value)
pulseIn(pin, value, timeout)
*/

/*
 * The following routine was generated by avr-gcc 4.8.3 with the following parameters
 * -gstabs -Wa,-ahlmsd=output.lst -dp -fverbose-asm -O2
 * on the original C function
 *
 * unsigned long pulseInSimpl(volatile uint8_t *port, uint8_t bit, uint8_t stateMask, unsigned long maxloops)
 * {
 *     unsigned long width = 0;
 *     // wait for any previous pulse to end
 *     while ((*port & bit) == stateMask)
 *         if (--maxloops == 0)
 *             return 0;
 *
 *     // wait for the pulse to start
 *     while ((*port & bit) != stateMask)
 *         if (--maxloops == 0)
 *             return 0;
 *
 *     // wait for the pulse to stop
 *     while ((*port & bit) == stateMask) {
 *         if (++width == maxloops)
 *             return 0;
 *     }
 *     return width;
 * }
 *
 * some compiler outputs were removed but the rest of the code is untouched
 */ 

unsigned long pulseIn(uint8_t pin, uint8_t state, unsigned long timeout)
{
// cache the port and bit of the pin in order to speed up the
// pulse width measuring loop and achieve finer resolution.  calling
// digitalRead() instead yields much coarser resolution.
uint8_t bit = digitalPinToBitMask(pin);
uint8_t port = digitalPinToPort(pin);
uint8_t stateMask = (state ? bit : 0);

// convert the timeout from microseconds to a number of times through
// the initial loop; it takes approximately 16 clock cycles per iteration
unsigned long maxloops = microsecondsToClockCycles(timeout)/16;

unsigned long width = countPulseASM(portInputRegister(port), bit, stateMask, maxloops);

// prevent clockCyclesToMicroseconds to return bogus values if countPulseASM timed out
if (width)
return clockCyclesToMicroseconds(width * 16 + 16);
else
return 0;
} 



unsigned long pulseInLong(uint8_t pin, uint8_t state, unsigned long timeout)
{
// cache the port and bit of the pin in order to speed up the
// pulse width measuring loop and achieve finer resolution.  calling
// digitalRead() instead yields much coarser resolution.
uint8_t bit = digitalPinToBitMask(pin);
uint8_t port = digitalPinToPort(pin);
uint8_t stateMask = (state ? bit : 0);

unsigned long startMicros = micros();

// wait for any previous pulse to end
while ((*portInputRegister(port) & bit) == stateMask) {
if (micros() - startMicros > timeout)
return 0;
}

// wait for the pulse to start
while ((*portInputRegister(port) & bit) != stateMask) {
if (micros() - startMicros > timeout)
return 0;
}

unsigned long start = micros();
// wait for the pulse to stop
while ((*portInputRegister(port) & bit) == stateMask) {
if (micros() - startMicros > timeout)
return 0;
}
return micros() - start;
} 

